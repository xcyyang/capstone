import argparse
import os

import cmd2
from cmd2 import (
    CommandSet,
    with_argparser,
    with_category,
    with_default_category,
)

from web3_exploit_framework.core.exceptions import (
    Development_Framework_Not_Initialized,
    Module_Creation_Error,
    Module_Reload_Error,
)
from web3_exploit_framework.core.module_manage import ModuleManager
from web3_exploit_framework.core.platform_dirs import get_development_framework_template_path
from web3_exploit_framework.core.ui.console.output import *
from web3_exploit_framework.core.ui.console.setting_store import (
    console_setting_store,
)
from web3_exploit_framework.core.utils.file import copy_folder, create_folder_if_not_exist


@with_default_category("Modules")
class LoadableModuleCommandSet(CommandSet):
    def __init__(self):
        super().__init__()
        self.module_manager = ModuleManager()
        self.current_module_name = None

    """
    List Command:
    This command is used to search exploits/PoCs with keywords
    """
    list_parser = cmd2.Cmd2ArgumentParser()
    list_parser.add_argument(
        "-n",
        "--name",
        nargs="?",
        help="the keywords for name of Exploits/PoCs",
    )
    list_parser.add_argument(
        "-date",
        "--date",
        nargs="?",
        help="the keywords for date",
    )
    list_parser.add_argument(
        "-c",
        "--chains",
        nargs="?",
        help="the keywords for the Exploits/PoCs in specific chain",
    )
    list_parser.add_argument(
        "-v",
        "--vulnerabilities",
        nargs="?",
        help="the keywords for vulnerability",
    )
    list_parser.add_argument(
        "-desc",
        "--description",
        nargs="?",
        help="the keywords for description",
    )
    list_parser.add_argument(
        "-e",
        "--exploits",
        nargs="?",
        help="the keywords for exploits",
    )

    def collect_results(self, result_set: dict, results: list):
        new_result = dict()
        for result in results:
            if(result['id'] in result_set.keys()):
                new_result[result['id']] = result
        return new_result

    @with_argparser(list_parser)  # type: ignore
    def do_list(self, opts: cmd2.Statement):
        result_set = dict()
        fields = ['name', 'date', 'description', 'vulnerabilities', 'chains', 'exploits']
        
        is_first_field = True
        for field in fields:
            if (getattr(opts, field) is not None):
                print(getattr(opts, field))
                if is_first_field:
                    for result in self.module_manager.search_modules_by_keyword(field, getattr(opts, field)):
                        result_set[result['id']] = result
                    is_first_field = False
                    continue
                result_set = self.collect_results(result_set, self.module_manager.search_modules_by_keyword(field, getattr(opts, field)))
        self.output_list_result(result_set)

    """
    Use Command:
    This command is used to load a existing exploits/PoCs
    """
    use_parser = cmd2.Cmd2ArgumentParser()
    use_parser.add_argument(
        "name", nargs="?", help="The module to be loaded/used"
    )
    use_parser.add_argument(
        "-r",
        "--run",
        action="store_true",
        help="run without any modification",
    )
    use_parser.add_argument(
        "-p",
        "--path",
        nargs="?",
        help="path to module",
    )

    def output_loaded_module_info(self, config: dict):
        self._cmd.poutput(output_good("Module Loaded:"))
        self._cmd.poutput(output_info("Description:"))
        self._cmd.poutput(output_good(config["info"]["description"]))
        self._cmd.poutput(output_info("License:"))
        self._cmd.poutput(output_good(config["info"]["license"]))
        self._cmd.poutput(output_info("Author:"))
        self._cmd.poutput(output_good(config["info"]["author"]))
        self._cmd.poutput(output_info("References:"))
        self._cmd.poutput(output_good(config["info"]["references"]))
        self._cmd.poutput(output_info("Chains:"))
        self._cmd.poutput(output_good(config["info"]["tags"]["chains"]))
        self._cmd.poutput(output_info("Project Type:"))
        self._cmd.poutput(output_good(config["info"]["tags"]["project"]))
        self._cmd.poutput(output_info("Vulnerabilities:"))
        self._cmd.poutput(
            output_good(config["info"]["tags"]["vulnerabilities"])
        )
        self._cmd.poutput(output_info("Exploits:"))
        self._cmd.poutput(output_good(config["info"]["tags"]["exploits"]))
    
    def output_module_info(self, info:dict):
        self._cmd.poutput(output_info("id: "))
        self._cmd.poutput(output_good(info["id"]))
        self._cmd.poutput(output_info("description: "))
        self._cmd.poutput(output_good(info["description"]))
        self._cmd.poutput(output_info("chains: "))
        self._cmd.poutput(output_good(info["chains"]))
        self._cmd.poutput(output_info("vulnerabilities: "))
        self._cmd.poutput(output_good(info["vulnerabilities"]))
    
    def output_list_result(self, results:dict):
        self._cmd.poutput(output_info("Results:"))
        self._cmd.poutput(output_info("------------------------------"))
        for key in results.keys():
            self.output_module_info(results[key])
            self._cmd.poutput(output_info("------------------------------"))

    @with_argparser(use_parser)  # type: ignore
    def do_use(self, opts: cmd2.Statement):
        try:
            if opts.name is not None:  # type: ignore
                module = None
                try:
                    module = self.module_manager.module_set.get(opts.name)
                    self._cmd.poutput(
                    output_warning("Existing Module Name")
                    )
                except KeyError:
                    module = self.module_manager.create(opts.name, opts.path)
                console_setting_store.load_config_yaml_to_settable(self._cmd, module.config)  # type: ignore
                self.current_module_name = opts.name  # type: ignore
                self._cmd.prompt = "({})({}) > ".format(Str("framework").red(), Str(opts.name).blue())  # type: ignore
                self.output_loaded_module_info(module.config)

                if opts.run:
                    self.module_manager.execute_module(self.current_module_name)
        except Module_Creation_Error:
            self._cmd.poutput(
                output_error("Module " + opts.name + " Not Found")
            )
    """
    Show Command
    Show the information of loaded module
    """
    def do_show(self,_: cmd2.Statement):
        if self.current_module_name is not None:
            module = self.module_manager.module_set.get(self.current_module_name)
            self.output_loaded_module_info(module.config)
    """
    Reload Command
    """
    def do_update(self, _: cmd2.Statement):
        try:
            if self.current_module_name is not None:
                self.module_manager.reload_module(self.current_module_name)
                module = self.module_manager.module_set.get(self.current_module_name)
                self.output_loaded_module_info(module.config)
        except Module_Reload_Error:
            self._cmd.poutput(
                output_error("Module Reload Error")
            )
    """
    Back Command
    This command unselect current loaded module
    """
    def do_back(self, _: cmd2.Statement):
        self.current_module_name = None
        console_setting_store.load_setting_yaml_to_settable(self._cmd)
        self._cmd.prompt = "({}) > ".format(Str("framework").red())

    """
    Run Command:
    This command is used to run/test a module (launch attack)
    """

    def do_run(self, _: cmd2.Statement):
        try:
            if self.current_module_name is not None:
                self.module_manager.execute_module(self.current_module_name)
            else:
                self._cmd.poutput(output_error("No Loaded Module"))
        except Development_Framework_Not_Initialized:
            self._cmd.poutput(
                output_error("Development Framework Not Initialized")
            )

    """
    Create Command
    This command is used to create a template for module
    """
    create_parser = cmd2.Cmd2ArgumentParser()
    create_parser.add_argument(
        "name", nargs="?", help="The module's name"
    )
    create_parser.add_argument(
        "-df",
        "--framework",
        nargs="?",
        help="The development framework for this module",
    )
    create_parser.add_argument(
        "-p",
        "--path",
        nargs="?",
        help="The path to creating module",
    )
    create_parser.add_argument(
        "-t",
        "--template",
        nargs="?",
        help="The template for this module",
    )
    @with_argparser(create_parser)
    def do_create(self, opts:cmd2.Statement):
        try:
            if opts.name is not None and opts.path is not None:
                path_to_new_module = os.path.join(opts.path, opts.name)
                path_to_new_module = os.path.expanduser(path_to_new_module)
                if opts.framework is not None:
                    path_to_template = get_development_framework_template_path(opts.framework)
                    create_folder_if_not_exist(path_to_new_module)
                    copy_folder(path_to_template, path_to_new_module)
                elif opts.template is not None:
                    path_to_template, _ = self.module_manager.get_config_of_module(opts.template)
                    create_folder_if_not_exist(path_to_new_module)
                    copy_folder(path_to_template, path_to_new_module)
                else:
                    return
                self._cmd.poutput(
                output_info("The to path to created module: ") +
                output_good(path_to_new_module)
            )
        except Exception as e:
            print(e)
            self._cmd.poutput(
                output_error("Failed to Create Template")
            )
