import argparse

import cmd2
from cmd2 import (
    CommandSet,
    with_argparser,
    with_category,
    with_default_category,
)

from web3_exploit_framework.core.exceptions import (
    Development_Framework_Not_Initialized,
    Module_Creation_Error,
)
from web3_exploit_framework.core.module_manage import ModuleManager
from web3_exploit_framework.core.ui.console.output import *
from web3_exploit_framework.core.ui.console.setting_store import (
    console_setting_store,
)


@with_default_category("Modules")
class LoadableModuleCommandSet(CommandSet):
    def __init__(self):
        super().__init__()
        self.module_manager = ModuleManager()
        self.current_module_name = None

    """
    List Command:
    This command is used to search exploits/PoCs with keywords
    """
    list_parser = cmd2.Cmd2ArgumentParser()
    list_parser.add_argument(
        "-n",
        "--name",
        nargs="?",
        help="the keywords for name of Exploits/PoCs",
    )
    list_parser.add_argument(
        "-c",
        "--chain",
        nargs="?",
        help="the keywords for the Exploits/PoCs in specific chain",
    )

    @with_argparser(list_parser)  # type: ignore
    def do_list(self, opts: cmd2.Statement):
        module_list = self.module_manager.search_modules_by_name(opts.name)  # type: ignore
        for module in module_list:
            self._cmd.poutput(output_good(module))

    """
    Use Command:
    This command is used to load a existing exploits/PoCs
    """
    use_parser = cmd2.Cmd2ArgumentParser()
    use_parser.add_argument(
        "name", nargs="?", help="The module to be loaded/used"
    )

    def output_module_info(self, config: dict):
        self._cmd.poutput(output_info("Description:"))
        self._cmd.poutput(output_good(config["info"]["description"]))
        self._cmd.poutput(output_info("License:"))
        self._cmd.poutput(output_good(config["info"]["license"]))
        self._cmd.poutput(output_info("Author:"))
        self._cmd.poutput(output_good(config["info"]["author"]))
        self._cmd.poutput(output_info("References:"))
        self._cmd.poutput(output_good(config["info"]["references"]))
        self._cmd.poutput(output_info("Chains:"))
        self._cmd.poutput(output_good(config["info"]["tags"]["chains"]))
        self._cmd.poutput(output_info("Project Type:"))
        self._cmd.poutput(output_good(config["info"]["tags"]["project"]))
        self._cmd.poutput(output_info("Vulnerabilities:"))
        self._cmd.poutput(
            output_good(config["info"]["tags"]["vulnerabilities"])
        )
        self._cmd.poutput(output_info("Exploits:"))
        self._cmd.poutput(output_good(config["info"]["tags"]["exploits"]))

    @with_argparser(use_parser)  # type: ignore
    def do_use(self, opts: cmd2.Statement):
        try:
            if opts.name is not None:  # type: ignore
                module = None
                try:
                    module = self.module_manager.module_set.get(opts.name)
                except KeyError:
                    module = self.module_manager.create(opts.name)
                console_setting_store.load_config_yaml_to_settable(self._cmd, module.config)  # type: ignore
                self.current_module_name = opts.name  # type: ignore
                self._cmd.prompt = "({})({}) > ".format(Str("framework").red(), Str(opts.name).blue())  # type: ignore
                self.output_module_info(module.config)
        except Module_Creation_Error:
            self._cmd.poutput(
                output_error("Module " + opts.name + " Not Found")
            )

    """
    Back Command
    This command unselect current loaded module
    """

    def do_back(self, _: cmd2.Statement):
        self.current_module_name = None
        console_setting_store.load_setting_yaml_to_settable(self._cmd)
        self._cmd.prompt = "({}) > ".format(Str("framework").red())

    """
    Run Command:
    This command is used to run/test a module (launch attack)
    """

    def do_run(self, _: cmd2.Statement):
        try:
            if self.current_module_name is not None:
                self.module_manager.execute_module(self.current_module_name)
            else:
                self._cmd.poutput(output_error("No Loaded Module"))
        except Development_Framework_Not_Initialized:
            self._cmd.poutput(
                output_error("Development Framework Not Initialized")
            )
