"""Manage the interaction with modules in terms of loading and instantiation"""
import os
from enum import Enum
from pysondb import db

from web3_exploit_framework.core.exceptions import (
    Development_Framework_Not_Initialized,
    Module_Already_Loaded,
    Module_Config_Not_Found,
    Module_Creation_Error,
    Module_Default_Database_Initialization_Error,
    Module_Execute_Error,
    Module_Load_Error,
    Module_Path_Not_Found,
    Module_Reload_Error,
    Module_Search_Error,
)
from web3_exploit_framework.core.module import Module
from web3_exploit_framework.core.platform_dirs import (
    get_data_folder_path,
    get_default_exploits_folder,
)
from web3_exploit_framework.core.setting import (
    save_setting_yaml_file,
    settings,
)
from web3_exploit_framework.core.utils.file import (
    create_folder_if_not_exist,
    find_subdirectory,
    read_yaml_file,
)


class ModuleSet:
    """The set to store module information"""

    _module_set = dict()

    def add(self, name, path, dev_mode=False):
        if name in self._module_set.keys():
            raise Module_Already_Loaded
        module = Module(name, path, dev_mode)
        self._module_set[name] = module

    def delete(self, name):
        self._module_set.pop(name)

    def get(self, name) -> Module:
        try:
            return self._module_set[name]
        except Exception as e:
            raise KeyError


class ModuleManager:
    DEFAULT_MODULE_DATABASE_PATH = get_default_exploits_folder()
    DEFAULT_MODULE_DATABASE_JSON = os.path.join(get_default_exploits_folder(), 'exploits.json')

    def __init__(self) -> None:
        # Init default module database path
        try:
            if not os.path.exists(self.DEFAULT_MODULE_DATABASE_PATH):
                create_folder_if_not_exist(self.DEFAULT_MODULE_DATABASE_PATH)
            # Init module set
            self.module_set = ModuleSet()
        except (Exception):
            raise Module_Default_Database_Initialization_Error

    def create(self, name, path=None) -> Module:
        try:
            path, config = self.get_config_of_module(name, path)
            self.module_set.add(name, path, config)
            return self.module_set.get(name)
        except (Exception):
            raise Module_Creation_Error

    def get_config_of_module(self, name, path=None):
        # Find module via users' path
        if path is not None:
            try:
                config = read_yaml_file(
                        os.path.join(path, "config.yml")
                    )
                return path, config
            except Exception as e:
                raise Module_Load_Error
        # Find module via default path        
        paths = list(settings["path"]["exploits"])
        paths.append(self.DEFAULT_MODULE_DATABASE_PATH)

        for path in paths:
            if os.path.exists(os.path.join(path, name, "config.yml")):
                try:
                    config = read_yaml_file(
                        os.path.join(path, name, "config.yml")
                    )
                    return os.path.join(path, name), config
                except Exception as e:
                    raise Module_Load_Error
        raise Module_Config_Not_Found

    def search_modules_by_name(self, keyword):
        try:
            module_list = find_subdirectory(
                keyword, self.DEFAULT_MODULE_DATABASE_PATH
            )
            return module_list
        except Exception as e:
            raise Module_Search_Error

    def search_modules_by_keyword(self, type, keyword):
        supported_types = ['id', 'name', 'date', 'description', 'project', 'exploits', 'vulnerabilities', 'chains']
        database = db.getDb(self.DEFAULT_MODULE_DATABASE_JSON)
        if type in supported_types:
            res = database.reSearch(type, r'(?i)(^.*)'+keyword+r'(.*$)')
            return res

    def get_loaded_module(self):
        """TODO"""
        pass

    def get_failed_module(self):
        """TODO"""
        pass

    def add_module_path(self, path):
        if os.path.exists(path):
            settings["path"]["exploits"].append(path)
            save_setting_yaml_file()
        else:
            raise Module_Path_Not_Found

    def remove_module_path(self):
        pass

    def execute_module(self, name):
        try:
            module = self.module_set.get(name)
            module.setup()
            module.run()
        except Development_Framework_Not_Initialized:
            raise Development_Framework_Not_Initialized
        except Exception as e:
            raise Module_Execute_Error

    def reload_module(self, name):
        try:
            path = self.module_set.get(name).path
            self.module_set.delete(name)
            self.create(name, path)
        except Exception as e:
            raise Module_Reload_Error

    def reload_modules(self):
        pass
